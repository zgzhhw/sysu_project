# bubble sort for eight numbers
.data
nums: .word 0x90,6,9,0x18,0x95,0x79,0x11,0x25
.space 200
sptop: 

.text
.globl main

main:
  la $sp,200 
  #la $sp,sptop             # 仅在Mars运行时启用，dump时注销
  la $a0,0
  #la $a0,nums               # 仅在Mars运行时启用，dump时注销
  li $a1,8
  jal sort
  la $s0,0                        
  #la $s0,nums              # 仅在Mars运行时启用，dump时注销
  lw $s1,0($s0)
  lw $s1,4($s0)
  lw $s1,8($s0)
  lw $s1,12($s0)
  lw $s1,16($s0)
  lw $s1,20($s0)
  lw $s1,24($s0)
  lw $s1,28($s0)
loop:    
   j loop

#v(数组) in $a0, k(个数) in $a1, i s0, j s1
sort:  
   addi $sp,$sp,-20      # make room on stack for 5 registers
         
   sw $ra, 16($sp) 
   sw $s3,12($sp) 
   sw $s2, 8($sp)
   sw $s1, 4($sp)
   sw $s0, 0($sp)
  
   move $s2, $a0
   move $s3, $a1

   move $s0, $zero           # i = 0
for1tst:
   slt    $t0, $s0, $s3          # $t0 = 0 if $s0 ≥ $s3 (i ≥ n)
   beq  $t0, $zero, exit1    # go to exit1 if $s0 ≥ $s3 (i ≥ n)
   addi $s1, $s0,-1             # j = i C 1
for2tst:
   slti    $t0, $s1, 0             # $t0 = 1 if $s1 < 0 (j < 0)
   bne  $t0, $zero, exit2    # go to exit2 if $s1 < 0 (j < 0)
   sll  $t1, $s1, 2                # $t1 = j * 4
   add  $t2, $s2, $t1          # $t2 = v + (j * 4)
   lw   $t3, 0($t2)               # $t3 = v[j]
   lw   $t4, 4($t2)               # $t4 = v[j + 1]
   slt  $t0, $t4, $t3             # $t0 = 0 if $t4 ≥ $t3
   beq  $t0, $zero, exit2     # go to exit2 if $t4 ≥ $t3
   move $a0, $s2               # 1st param of swap is v (old $a0)
   move $a1, $s1               # 2nd param of swap is j
   jal  swap                       # call swap procedure
   addi $s1, $s1,-1             # j C= 1
    j    for2tst                     # jump to test of inner loop
exit2:
    addi $s0, $s0, 1             # i += 1
     j    for1tst                    # jump to test of outer loop
exit1:
    lw $ra,16($sp) 
    lw $s0, 0($sp)
    lw $s1, 4($sp)
    lw $s2, 8($sp)
    lw $s3,12($sp)
    addi $sp,$sp, 20
    jr $ra

swap: 
    sll $t1, $a1, 2   # $t1 = k * 4
    add $t1, $a0, $t1 # $t1 = v+(k*4)
                              #   (address of v[k])
    lw $t0, 0($t1)    # $t0 (temp) = v[k]
    lw $t2, 4($t1)    # $t2 = v[k+1]
    sw $t2, 0($t1)    # v[k] = $t2 (v[k+1])
    sw $t0, 4($t1)    # v[k+1] = $t0 (temp)
    jr $ra            # return to calling routine

